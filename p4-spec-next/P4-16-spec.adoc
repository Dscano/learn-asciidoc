= P4~16~ Language Specification
The P4 Language Consortium
:toc: macro
:toclevels: 5
:imagesdir: figs
:sectnums:
:xrefstyle: short

== Abstract

P4 is a language for programming the data plane of network
devices. This document provides a precise definition of the P4~16~
language, which is the 2016 revision of the P4 language
(<http://p4.org>). The target audience for this document includes
developers who want to write compilers, simulators, IDEs, and
debuggers for P4 programs. This document may also be of interest to P4
programmers who are interested in understanding the syntax and
semantics of the language at a deeper level.

toc::[]

== Scope

This specification document defines the structure and interpretation
of programs in the P4~16~ language. It defines the syntax, semantic
rules, and requirements for conformant implementations of the
language.

It does not define:

* Mechanisms by which P4 programs are compiled, loaded, and executed
  on packet-processing systems,
* Mechanisms by which data are received by one packet-processing
  system and delivered to another system,
* Mechanisms by which the control plane manages the match-action
  tables and other stateful objects defined by P4 programs,
* The size or complexity of P4 programs,
* The minimal requirements of packet-processing systems that are
  capable of providing a conformant implementation.

It is understood that some implementations may be unable to implement
the behavior defined here in all cases, or may provide options to
eliminate some safety guarantees in exchange for better performance or
handling larger programs.  They should document where they deviate
from this specification.


== Terms, definitions, and symbols

Throughout this document, the following terms will be used:

* *Architecture*: A set of P4-programmable components and the data
  plane interfaces between them.
* *Control plane*: A class of algorithms and the corresponding input
  and output data that are concerned with the provisioning and
  configuration of the data plane.
* *Data plane*: A class of algorithms that describe transformations
  on packets by packet-processing systems.
* *Metadata*: Intermediate data generated during execution of a P4
  program.
* *Packet*: A network packet is a formatted unit of data carried by
  a packet-switched network.
* *Packet header*: Formatted data at the beginning of a packet. A
  given packet may contain a sequence of packet headers representing
  different network protocols.
* *Packet payload*: Packet data that follows the packet headers.
* *Packet-processing system*: A data-processing system designed
 for processing network packets. In general, packet-processing
  systems implement control plane and data plane algorithms.
* *Target*: A packet-processing system capable of executing a P4
  program.

All terms defined explicitly in this document should not be understood
to refer implicitly to similar terms defined elsewhere. Conversely, any terms not
defined explicitly in this document should be interpreted according to
generally recognizable sources---e.g., IETF RFCs.



== Overview

.Traditional switches vs. programmable switches.
[#fig-prgswitch]
image::prgswitch.png[]

P4 is a language for expressing how packets are processed by the data
plane of a programmable forwarding element such as a hardware or
software switch, network interface card, router, or network
appliance. The name P4 comes from the original paper that introduced
the language, "Programming Protocol-independent Packet Processors,"
<https://arxiv.org/pdf/1312.1719.pdf>. While P4 was initially designed
for programming switches, its scope has been broadened to cover a
large variety of devices. In the rest of this document we use the
generic term _target_ for all such devices.

Many targets implement both a control plane and a data plane. P4 is
designed to specify only the data plane functionality of the
target. P4 programs also partially define the interface by which the
control plane and the data-plane communicate, but P4 cannot be used to
describe the control-plane functionality of the target. In the rest of
this document, when we talk about P4 as "programming a target", we
mean "programming the data plane of a target".

As a concrete example of a target, <<fig-prgswitch>> illustrates
the difference between a traditional fixed-function switch and a
P4-programmable switch. In a traditional switch the manufacturer
defines the data-plane functionality. The control-plane controls the
data plane by managing entries in tables (e.g. routing tables),
configuring specialized objects (e.g. meters), and by processing
control-packets (e.g. routing protocol packets) or asynchronous
events, such as link state changes or learning notifications.

A P4-programmable switch differs from a traditional switch in two
essential ways:

* The data plane functionality is not fixed in advance but is defined
  by a P4 program. The data plane is configured at initialization
  time to implement the functionality described by the P4 program
  (shown by the long red arrow) and has no built-in knowledge of
  existing network protocols.
* The control plane communicates with the data plane using the same
  channels as in a fixed-function device, but the set of tables and
  other objects in the data plane are no longer fixed, since they are
  defined by a P4 program. The P4 compiler generates the API that the
  control plane uses to communicate with the data plane.

Hence, P4 can be said to be protocol independent, but it enables
programmers to express a rich set of protocols and other data plane
behaviors.

.Programming a target with P4.
[#fig-p4prg]
image::p4prg.png[]

The core abstractions provided by the P4 language are:

* *Header types* describe the format (the set of fields and
  their sizes) of each header within a packet.
* *Parsers* describe the permitted sequences of headers within
  received packets, how to identify those header sequences, and the
  headers and fields to extract from packets.
* *Tables* associate user-defined keys with actions. P4 tables
  generalize traditional switch tables; they can be used to implement
  routing tables, flow lookup tables, access-control lists, and other
  user-defined table types, including complex multi-variable decisions.
* *Actions* are code fragments that describe how packet header
  fields and metadata are manipulated. Actions can include data, which
  is supplied by the control-plane at runtime.
* *Match-action units* perform the following sequence of operations:
** Construct lookup keys from packet fields or computed metadata,
** Perform table lookup using the constructed key, choosing an action
   (including the associated data) to execute, and
** Finally, execute the selected action.
* *Control flow* expresses an imperative program that describes
  packet-processing on a target, including the data-dependent sequence
  of match-action unit invocations. Deparsing (packet reassembly) can
  also be performed using a control flow.
* *Extern objects* are architecture-specific constructs that can be
  manipulated by P4 programs through well-defined APIs, but whose
  internal behavior is hard-wired (e.g., checksum units) and hence not
  programmable using P4.
* *User-defined metadata*: user-defined data structures associated
  with each packet.
* *Intrinsic metadata*: metadata provided by the architecture
  associated with each packet---e.g., the input port where a packet
  has been received.

<<fig-p4prg>> shows a typical tool workflow when programming a
target using P4.

Target manufacturers provide the hardware or software implementation
framework, an architecture definition, and a P4 compiler for that
target. P4 programmers write programs for a specific architecture,
which defines a set of P4-programmable components on the target as
well as their external data plane interfaces.

Compiling a set of P4 programs produces two artifacts:

* a data plane configuration that implements the forwarding logic
  described in the input program and
* an API for managing the state of the data plane objects from the
  control plane

P4 is a domain-specific language that is designed to be implementable
on a large variety of targets including programmable network interface
cards, FPGAs, software switches, and hardware ASICs. As such, the
language is restricted to constructs that can be efficiently
implemented on all of these platforms.

Assuming a fixed cost for table lookup operations and interactions
with extern objects, all P4 programs (i.e., parsers and controls)
execute a constant number of operations for each byte of an input
packet received and analyzed. Although parsers may contain loops,
provided some header is extracted on each cycle, the packet itself
provides a bound on the total execution of the parser. In other words,
under these assumptions, the computational complexity of a P4 program
is linear in the total size of all headers, and never depends on the
size of the state accumulated while processing data (e.g., the number
of flows, or the total number of packets processed). These guarantees
are necessary (but not sufficient) for enabling fast packet processing
across a variety of targets.

_P4 conformance_ of a target is defined as follows: if a specific
target T supports only a subset of the P4 programming language, say
P4^T^, programs written in P4^T^ executed on the target should provide
the exact same behavior as is described in this document. Note that P4
conformant targets can provide arbitrary P4 language extensions and `extern`
elements.

=== Benefits of P4

Compared to state-of-the-art packet-processing systems (e.g., based on
writing microcode on top of custom hardware), P4 provides a number of
significant advantages:

* *Flexibility*: P4 makes many packet-forwarding policies
  expressible as programs, in contrast to traditional switches, which
  expose fixed-function forwarding engines to their users.
* *Expressiveness*: P4 can express sophisticated,
  hardware-independent packet processing algorithms using solely
  general-purpose operations and table look-ups. Such programs are
  portable across hardware targets that implement the same
  architectures (assuming sufficient resources are available).
* *Resource mapping and management*: P4 programs describe storage
  resources abstractly (e.g., IPv4 source address); compilers map such
  user-defined fields to available hardware resources and manage
  low-level details such as allocation and scheduling.
* *Software engineering*: P4 programs provide important benefits
  such as type checking, information hiding, and software reuse.
* *Component libraries*: Component libraries supplied by manufacturers
  can be used to wrap hardware-specific functions into portable
  high-level P4 constructs.
* *Decoupling hardware and software evolution*: Target manufacturers
  may use abstract architectures to further decouple the evolution of
  low-level architectural details from high-level processing.
* *Debugging*: Manufacturers can provide software models of an
  architecture to aid in the development and debugging of P4 programs.

=== P4 language evolution: comparison to previous versions (P4 v1.0/v1.1)

.Evolution of the language between versions P4~14~ (versions 1.0 and 1.1) and P4~16~.
[#fig-p4transition]
image::p4transition.png[]

Compared to P4~14~, the earlier version of the language, P4~16~ makes
a number of significant, backwards-incompatible changes to the syntax
and semantics of the language. The evolution from the previous version
(P4~14~) to the current one (P4~16~) is depicted in
<<fig-p4transition>>. In particular, a large number of language
features have been eliminated from the language and moved into
libraries including counters, checksum units, meters, etc.

Hence, the language has been transformed from a complex language (more than 70
keywords) into a relatively small core language (less than 40 keywords, shown in
<<_appendix_p4_reserved_keywords>>) accompanied by a library of fundamental
constructs that are needed for writing most P4.

The v1.1 version of P4 introduced a language construct called `extern` that
can be used to describe library elements. Many constructs defined in the
v1.1 language specification will thus be transformed into such
library elements (including constructs that have been eliminated
from the language, such as counters and meters). Some of these `extern` objects
are expected to be standardized, and they will be in the scope of a
future document describing a standard library of P4 elements. In
this document we provide several examples of `extern` constructs.
P4~16~ also introduces and repurposes some v1.1 language
constructs for describing the programmable parts of an
architecture. These language constructs are: `parser`, `state`, `control`, and `package`.

One important goal of the P4~16~ language revision is to provide a
*stable* language definition. In other words, we strive to ensure that
all programs written in P4~16~ will remain syntactically correct and
behave identically when treated as programs for future versions of the
language. Moreover, if some future version of the language requires
breaking backwards compatibility, we will seek to provide an easy path
for migrating P4~16~ programs to the new version.


== Architecture Model

.P4 program interfaces.
[#fig-p4interface]
image::p4interface.png[]

The _P4 architecture_ identifies the P4-programmable blocks (e.g.,
parser, ingress control flow, egress control flow, deparser, etc.) and their
data plane interfaces.

The P4 architecture can be thought of as a contract between the
program and the target.
Each manufacturer must therefore
provide both a P4 compiler as well as an accompanying
architecture definition for their target. (We expect that P4 compilers
can share a common front-end that handles all architectures). The architecture
definition does not have to expose the entire programmable surface of
the data plane---a manufacturer may even choose to provide multiple
definitions for the same hardware device, each with different
capabilities (e.g., with or without multicast support).

<<fig-p4interface>> illustrates the data plane interfaces between P4-programmable
blocks. It shows a target that has two programmable blocks (#1 and #2).
Each block is programmed through a separate fragment of P4 code. The
target interfaces with the P4 program through a set of control
registers or signals. Input controls provide information to P4
programs (e.g., the input port that a packet was received from), while
output controls can be written to by P4 programs to influence the
target behavior (e.g., the output port where a packet has to be
directed). Control registers/signals are represented in P4 as
_intrinsic metadata_.
P4 programs can also store and manipulate data pertaining to each
packet as _user-defined metadata_.

The behavior of a P4 program can be fully described in terms of
transformations that map vectors of bits to vectors of bits. To actually
process a packet, the architecture
model interprets the bits that the P4 program writes to intrinsic metadata.
For example, to cause a packet to
be forwarded on a specific output port, a P4 program may need to write
the index of an output port into a dedicated control register. Similarly,
to cause a packet to be dropped, a P4 program may need to set a
"drop" bit into another dedicated control register. Note that the details of
how intrinsic metadata are interpreted is architecture-specific.

.P4 program invoking the services of a fixed-function object.
[#fig-p4checksum]
image::p4checksum.png[]

P4 programs can invoke services implemented by extern objects and functions provided by the architecture.
<<fig-p4checksum>> depicts a P4 program invoking the services of a
built-in checksum computation unit on a target. The implementation of the checksum
unit is not specified in P4, but its interface is. In general, the interface for
an extern object describes each operation it provides, as well as their parameter and return types.

In general, P4 programs are not expected to be portable across
different architectures. For example, executing a P4 program that
broadcasts packets by writing into a custom control register
will not function correctly on a target that does not have the control
register. However, P4 programs written for a given architecture should
be portable across all targets that faithfully implement the
corresponding model, provided there are sufficient resources.

=== Standard architectures

We expect that the P4 community will evolve a small set of standard architecture
models pertaining to specific verticals. Wide adoption of such standard
architectures will promote portability of P4 programs across different targets.
However, defining these
standard architectures is outside of the scope of this document.

=== Data plane interfaces

To describe a functional block that can be programmed in P4, the
architecture includes a type declaration that specifies the interfaces
between the block and the other components in the architecture.
For example, the architecture might contain a declaration such as the following:

[source,P4]
----
control MatchActionPipe<H>(in bit<4> inputPort,
                           inout H parsedHeaders,
                           out bit<4> outputPort);
----

This type declaration describes a block named `MatchActionPipe`
that can be programmed using a data-dependent sequence of match-action
unit invocations and other imperative constructs (indicated by the `control`
keyword).  The interface between the `MatchActionPipe` block and
the other components of the architecture can be read off from this declaration:

* The first parameter is a 4-bit value named `inputPort.` The
  direction `in` indicates that this parameter is an input that
  cannot be modified.
* The second parameter is an object of type `H` named `parsedHeaders`,
  where `H` is a type variable representing the headers that will
  be defined later by the P4 programmer.
  The direction `inout` indicates that this parameter is
  both an input and an output.
* The third parameter is a 4-bit value named `outputPort`. The
  direction `out` indicates that this parameter is an output
  whose value is undefined initially but can be modified.

=== Extern objects and functions

P4 programs can also interact with objects and functions provided by the architecture.
Such objects are described using the `extern` construct, which
describes the interfaces that such objects expose to the data-plane.

An `extern` object describes a set of methods that are implemented
by an object, but not the implementation of these methods (i.e., it is similar
to an abstract class in an object-oriented language). For example,
the following construct could be used to describe the operations offered by an
incremental checksum unit:

[source,P4]
----
extern Checksum16 {
    Checksum16();              // constructor
    void clear();              // prepare unit for computation
    void update<T>(in T data); // add data to checksum
    void remove<T>(in T data); // remove data from existing checksum
    bit<16> get(); // get the checksum for the data added since last clear
}
----


== Example: A very simple switch

As an example to illustrate the features of architectures, consider
implementing a very simple switch in P4. We will first describe the
architecture of the switch and then write a complete P4 program
that specifies the data plane behavior of the switch. This example
demonstrates many important features of the P4 programming language.

.The Very Simple Switch (VSS) architecture.
[#fig-vssarch]
image::vssarch.png[]

We call our architecture the "Very Simple Switch" (VSS).
<<fig-vssarch>> is a diagram of this architecture. There is nothing inherently
special about VSS---it is just a pedagogical example that
illustrates how programmable switches can be described and programmed
in P4. VSS has a number of fixed-function blocks (shown in cyan in our
example), whose behavior is described in Section [#sec_vssarch]. The
white blocks are programmable using P4.

VSS receives packets through one of 8 input Ethernet ports, through a
recirculation channel, or from a port connected directly to the
CPU. VSS has one single parser, feeding into a single match-action
pipeline, which feeds into a single deparser. After exiting the
deparser, packets are emitted through one of 8 output Ethernet ports
or one of 3 "special" ports:

* Packets sent to the "CPU port" are sent to the control plane
* Packets sent to the "Drop port" are discarded
* Packets sent to the "Recirculate port" are re-injected in the switch
  through a special input port

The white blocks in the figure are programmable, and the user must
provide a corresponding P4 program to specify the behavior of each
such block. The red arrows indicate the flow of user-defined data.  The
cyan blocks are fixed-function components. The green arrows are data plane
interfaces used to convey information between the fixed-function
blocks and the programmable blocks---exposed in the P4 program as
intrinsic metadata.


=== Very Simple Switch Architecture

The following P4 program provides a declaration of VSS in P4, as it
would be provided by the VSS manufacturer. The declaration contains
several type declarations, constants, and finally declarations for the
three programmable blocks; the code uses syntax highlighting. The
programmable blocks are described by their types; the implementation
of these blocks has to be provided by the switch programmer.

[source,P4]
----
// File "very_simple_switch_model.p4"
// Very Simple Switch P4 declaration
// core library needed for packet_in and packet_out definitions
# include <core.p4>
/* Various constants and structure declarations */
/* ports are represented using 4-bit values */
typedef bit<4> PortId;
/* only 8 ports are "real" */
const PortId REAL_PORT_COUNT = 4w8;  // 4w8 is the number 8 in 4 bits
/* metadata accompanying an input packet */
struct InControl {
    PortId inputPort;
}
/* special input port values */
const PortId RECIRCULATE_IN_PORT = 0xD;
const PortId CPU_IN_PORT = 0xE;
/* metadata that must be computed for outgoing packets */
struct OutControl {
    PortId outputPort;
}
/* special output port values for outgoing packet */
const PortId DROP_PORT = 0xF;
const PortId CPU_OUT_PORT = 0xE;
const PortId RECIRCULATE_OUT_PORT = 0xD;
/* Prototypes for all programmable blocks */
/**
 * Programmable parser.
 * @param <H> type of headers; defined by user
 * @param b input packet
 * @param parsedHeaders headers constructed by parser
 */
parser Parser<H>(packet_in b,
                 out H parsedHeaders);
/**
 * Match-action pipeline
 * @param <H> type of input and output headers
 * @param headers headers received from the parser and sent to the deparser
 * @param parseError error that may have surfaced during parsing
 * @param inCtrl information from architecture, accompanying input packet
 * @param outCtrl information for architecture, accompanying output packet
 */
control Pipe<H>(inout H headers,
                in error parseError,// parser error
                in InControl inCtrl,// input port
                out OutControl outCtrl); // output port
/**
 * VSS deparser.
 * @param <H> type of headers; defined by user
 * @param b output packet
 * @param outputHeaders headers for output packet
 */
control Deparser<H>(inout H outputHeaders,
                    packet_out b);
/**
 * Top-level package declaration - must be instantiated by user.
 * The arguments to the package indicate blocks that
 * must be instantiated by the user.
 * @param <H> user-defined type of the headers processed.
 */
package VSS<H>(Parser<H> p,
               Pipe<H> map,
               Deparser<H> d);
// Architecture-specific objects that can be instantiated
// Checksum unit
extern Checksum16 {
    Checksum16();              // constructor
    void clear();              // prepare unit for computation
    void update<T>(in T data); // add data to checksum
    void remove<T>(in T data); // remove data from existing checksum
    bit<16> get(); // get the checksum for the data added since last clear
}
----
Let us describe some of these elements:

* The included file `core.p4` is described in more detail in
  <<_appendix_p4_core_library>>. It defines some standard
  data-types and error codes.
* `bit<4>` is the type of bit-strings with 4 bits.
* The syntax `4w0xF` indicates the value 15 represented using 4
  bits. An alternative notation is `4w15`. In many circumstances
  the width modifier can be omitted, writing just `15`.
* `error` is a built-in P4 type for holding error codes
* Next follows the declaration of a parser:
[source,P4]
----
parser Parser<H>(packet_in b, out H parsedHeaders);
----
This declaration describes the interface for a parser, but not yet its
implementation, which will be provided by
the programmer. The parser reads its input from a `packet_in`, which is
a pre-defined P4 extern object that represents an incoming
packet, declared in the `core.p4` library. The parser writes its
output (the `out` keyword) into the `parsedHeaders`
argument. The type of this argument is `H`, yet unknown---it will
also be provided by the programmer.

* The declaration
[source,P4]
----
control Pipe<H>(inout H headers,
                in error parseError,
                in InControl inCtrl,
                out OutControl outCtrl);
----
describes the interface of a Match-Action pipeline named `Pipe`.

The pipeline receives three inputs: the headers `headers`, a parser
error `parseError`, and the `inCtrl` control data.
<<fig-vssarch>> indicates the different sources of these pieces of
information. The pipeline writes its outputs into `outCtrl`, and
it must update in place the headers to be consumed by the deparser.

* The top-level package is called `VSS`; in order to program a
  VSS, the user will have to instantiate a package of this type (shown
  in the next section). The top-level package declaration also depends
  on a type variable H:
[source,P4]
----
package VSS<H>
----

A type variable indicates a type yet unknown that must be provided by
the user at a later time. In this case `H` is the type of the set
of headers that the user program will be processing; the parser will
produce the parsed representation of these headers, and the
match-action pipeline will update the input headers in place to
produce the output headers.

* The `package VSS` declaration has three complex parameters, of
  types `Parser`, `Pipe`, and `Deparser` respectively; which are
  exactly the declarations we have just described. In order to program
  the target one has to supply values for these parameters.
* In this program the `inCtrl` and `outCtrl` structures
  represent control registers. The content of the headers structure is
  stored in general-purpose registers.
* The `extern Checksum16` declaration describes an extern object
  whose services can be invoked to compute checksums.

=== Very Simple Switch Architecture Description

In order to fully understand VSS's behavior and write meaningful P4
programs for it, and for implementing a control plane, we also need a
full behavioral description of the fixed-function blocks. This section
can be seen as a simple example illustrating all the details that have
to be handled when writing an architecture description. The P4
language is not intended to cover the description of all such
functional blocks---the language can only describe the interfaces
between programmable blocks and the architecture. For the current program,
this interface is given by the `Parser`, `Pipe`, and `Deparser`
declarations. In practice we expect that the complete description of the architecture
will be provided as an executable program and/or diagrams and text; in
this document we will provide informal descriptions in English.

==== Arbiter block

The input arbiter block performs the following functions:

* It receives packets from one of the physical input Ethernet ports,
  from the control plane, or from the input recirculation port.
* For packets received from Ethernet ports, the block computes the
  Ethernet trailer checksum and verifies it. If the checksum does not
  match, the packet is discarded. If the checksum does match, it is
  removed from the packet payload.
* Receiving a packet involves running an arbitration algorithm if
  multiple packets are available.
* If the arbiter block is busy processing a previous packet and no
  queue space is available, input ports may drop arriving packets,
  without indicating the fact that the packets were dropped in any
  way.
* After receiving a packet, the arbiter block sets the `inCtrl.inputPort`
  value that is an input to the match-action pipeline with the identity of the input
  port where the packet originated. Physical Ethernet ports are
  numbered 0 to 7, while the input recirculation port has a number 13
  and the CPU port has the number 14.

==== Parser runtime block

The parser runtime block works in concert with the parser. It provides
an error code to the match-action pipeline, based on the parser
actions, and it provides information about the packet payload (e.g.,
the size of the remaining payload data) to the demux block. As soon as
a packet's processing is completed by the parser, the match-action
pipeline is invoked with the associated metadata as inputs (packet
headers and user-defined metadata).

==== Demux block

The core functionality of the demux block is to receive the headers
for the outgoing packet from the deparser and the packet payload from
the parser, to assemble them into a new packet and to send the result
to the correct output port. The output port is specified by the value
of `outCtrl.ouputPort`, which is set by the match-action pipeline.

* Sending the packet to the drop port causes the packet to disappear.
* Sending the packet to an output Ethernet port numbered between 0 and
  7 causes it to be emitted on the corresponding physical
  interface. The packet may be placed in a queue if the output
  interface is already busy emitting another packet. When the packet is
  emitted, the physical interface computes a correct Ethernet checksum
  trailer and appends it to the packet.
* Sending a packet to the output CPU port causes the packet to be
  transferred to the control plane. In this case, the packet that is
  sent to the CPU is the **original input packet**, and not the packet
  received from the deparser---the latter packet is discarded.
* Sending the packet to the output recirculation port causes it to
  appear at the input recirculation port. Recirculation is useful when
  packet processing cannot be completed in a single pass.
* If the `outputPort` has an illegal value (e.g., 9), the packet
  is dropped.
* Finally, if the demux unit is busy processing a previous packet and there is
  no capacity to queue the packet coming from the deparser, **the
  demux unit may drop the packet**, irrespective of the output port indicated.

Please note that some of the behaviors of the demux block may be
unexpected---we have highlighted them in bold. We are not specifying
here several important behaviors related to queue size, arbitration,
and timing, which also influence the packet processing.

The arrow shown from the parser runtime to the demux block represents
an additional information flow from the parser to the demux: the
packet being processed as well as the offset within the packet where
parsing ended (i.e., the start of the packet payload).

==== Available extern blocks

The VSS architecture provides an incremental checksum extern block,
called `Checksum16`. The checksum unit has a constructor and four
methods:

* `clear()`: prepares the unit for a new computation
* `update<T>(in T data)`: add some data to be checksummed. The
  data must be either a bit-string, a header-typed value, or a `struct`
  containing such values. The fields in the header/struct
  are concatenated in the order they appear in the type declaration.
* `get()`: returns the 16-bit one's complement checksum. When
  this function is invoked the checksum must have received an integral
  number of bytes of data.
* `remove<T>(in T data)`: assuming that `data`
  was used for computing the current checksum, `data` is removed
  from the checksum.

=== A complete Very Simple Switch program

Here we provide a complete P4 program that implements basic forwarding for
IPv4 packets on the VSS architecture. This program does not utilize all of the
features provided by the architecture---e.g., recirculation---but it does use
preprocessor `#include` directives (see <<_preprocessing>>).

.Diagram of the match-action pipeline expressed by the VSS P4 program.
[#fig-vssmau]
image::vssmau.png[]

The parser attempts to recognize an Ethernet header followed by an IPv4 header.
If either of these headers are missing, parsing terminates with an
error. Otherwise it extracts the information from these headers into
a `Parsed_packet` structure. The match-action pipeline is
shown in <<fig-vssmau>>; it comprises four match-action units
(represented by the P4 `table` keyword):

* If any parser error has occurred, the packet is dropped (i.e., by assigning `outputPort`
  to `DROP_PORT`)
* The first table uses the IPv4 destination address to determine the `outputPort`
  and the IPv4 address of the next hop. If this lookup fails, the packet is dropped.
  The table also decrements the IPv4 `ttl` value.
* The second table checks the `ttl` value: if the `ttl` becomes 0, the
  packet is sent to the control plane through the CPU port.
* The third table uses the IPv4 address of the next hop (which was computed by
  the first table) to determine the Ethernet address of the next hop.
* Finally, the last table uses the `outputPort` to identify the
  source Ethernet address of the current switch, which is set in the
  outgoing packet.

The deparser constructs the outgoing packet by reassembling the Ethernet and
IPv4 headers as computed by the pipeline.

[source,P4]
----
// Include P4 core library
# include <core.p4>

// Include very simple switch architecture declarations
# include "very_simple_switch_model.p4"

// This program processes packets comprising an Ethernet and an IPv4
// header, and it forwards packets using the destination IP address

typedef bit<48>  EthernetAddress;
typedef bit<32>  IPv4Address;

// Standard Ethernet header
header Ethernet_h {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

// IPv4 header (without options)
header IPv4_h {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      totalLen;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    IPv4Address  srcAddr;
    IPv4Address  dstAddr;
}

// Structure of parsed headers
struct Parsed_packet {
    Ethernet_h ethernet;
    IPv4_h     ip;
}

// Parser section

// User-defined errors that may be signaled during parsing
error {
    IPv4OptionsNotSupported,
    IPv4IncorrectVersion,
    IPv4ChecksumError
}

parser TopParser(packet_in b, out Parsed_packet p) {
    Checksum16() ck;  // instantiate checksum unit

    state start {
        b.extract(p.ethernet);
        transition select(p.ethernet.etherType) {
            0x0800: parse_ipv4;
            // no default rule: all other packets rejected
        }
    }

    state parse_ipv4 {
        b.extract(p.ip);
        verify(p.ip.version == 4w4, error.IPv4IncorrectVersion);
        verify(p.ip.ihl == 4w5, error.IPv4OptionsNotSupported);
        ck.clear();
        ck.update(p.ip);
        // Verify that packet checksum is zero
        verify(ck.get() == 16w0, error.IPv4ChecksumError);
        transition accept;
    }
}

// Match-action pipeline section

control TopPipe(inout Parsed_packet headers,
                in error parseError, // parser error
                in InControl inCtrl, // input port
                out OutControl outCtrl) {
     IPv4Address nextHop;  // local variable

     /**
      * Indicates that a packet is dropped by setting the
      * output port to the DROP_PORT
      */
      action Drop_action() {
          outCtrl.outputPort = DROP_PORT;
      }

     /**
      * Set the next hop and the output port.
      * Decrements ipv4 ttl field.
      * @param ipv4_dest ipv4 address of next hop
      * @param port output port
      */
      action Set_nhop(IPv4Address ipv4_dest, PortId port) {
          nextHop = ipv4_dest;
          headers.ip.ttl = headers.ip.ttl - 1;
          outCtrl.outputPort = port;
      }

     /**
      * Computes address of next IPv4 hop and output port
      * based on the IPv4 destination of the current packet.
      * Decrements packet IPv4 TTL.
      * @param nextHop IPv4 address of next hop
      */
     table ipv4_match {
         key = { headers.ip.dstAddr: lpm; }  // longest-prefix match
         actions = {
              Drop_action;
              Set_nhop;
         }
         size = 1024;
         default_action = Drop_action;
     }

     /**
      * Send the packet to the CPU port
      */
      action Send_to_cpu() {
          outCtrl.outputPort = CPU_OUT_PORT;
      }

     /**
      * Check packet TTL and send to CPU if expired.
      */
     table check_ttl {
         key = { headers.ip.ttl: exact; }
         actions = { Send_to_cpu; NoAction; }
         const default_action = NoAction; // defined in core.p4
     }

     /**
      * Set the destination MAC address of the packet
      * @param dmac destination MAC address.
      */
      action Set_dmac(EthernetAddress dmac) {
          headers.ethernet.dstAddr = dmac;
      }

     /**
      * Set the destination Ethernet address of the packet
      * based on the next hop IP address.
      * @param nextHop IPv4 address of next hop.
      */
      table dmac {
          key = { nextHop: exact; }
          actions = {
               Drop_action;
               Set_dmac;
          }
          size = 1024;
          default_action = Drop_action;
      }

      /**
       * Set the source MAC address.
       * @param smac: source MAC address to use
       */
       action Set_smac(EthernetAddress smac) {
           headers.ethernet.srcAddr = smac;
       }

      /**
       * Set the source mac address based on the output port.
       */
      table smac {
           key = { outCtrl.outputPort: exact; }
           actions = {
                Drop_action;
                Set_smac;
          }
          size = 16;
          default_action = Drop_action;
      }

      apply {
          if (parseError != error.NoError) {
              Drop_action();  // invoke drop directly
              return;
          }

          ipv4_match.apply(); // Match result will go into nextHop
          if (outCtrl.outputPort == DROP_PORT) return;

          check_ttl.apply();
          if (outCtrl.outputPort == CPU_OUT_PORT) return;

          dmac.apply();
          if (outCtrl.outputPort == DROP_PORT) return;

          smac.apply();
    }
}

// deparser section
control TopDeparser(inout Parsed_packet p, packet_out b) {
    Checksum16() ck;
    apply {
        b.emit(p.ethernet);
        if (p.ip.isValid()) {
            ck.clear();              // prepare checksum unit
            p.ip.hdrChecksum = 16w0; // clear checksum
            ck.update(p.ip);         // compute new checksum.
            p.ip.hdrChecksum = ck.get();
        }
        b.emit(p.ip);
    }
}

// Instantiate the top-level VSS package
VSS(TopParser(),
    TopPipe(),
    TopDeparser()) main;
----


== P4 language definition

The P4 language can be viewed as having several distinct components,
which we describe separately:

* The core language, comprising of types, variables, scoping,
  declarations, statements, expressions, etc. We start by describing
  this part of the language.
* A sub-language for expressing parsers, based on state machines
  (<<_packet_parsing>>).
* A sub-language for expressing computations using match-action units, based on
  traditional imperative control-flow (<<_control_blocks>>).
* A sub-language for describing architectures (<<_architecture_description>>).

=== Syntax and semantics

==== Grammar

The complete grammar of P4~16~ is given in <<_appendix_p4_grammar>>,
using Yacc/Bison grammar description language. This text is based on
the same grammar. We adopt several standard conventions when we provide
excerpts from the grammar:

* `UPPERCASE` symbols denote terminals in the grammar.
* Excerpts from the grammar are given in BNF notation as follows:
[source,bison]
----
include::grammar.adoc[tag=p4program]
----

Pseudo-code (mostly used for describing the semantics of
various P4 constructs) are shown with fixed-size fonts as in the
following example:

[source,P4Pseudo]
----
ParserModel.verify(bool condition, error err) {
    if (condition == false) {
        ParserModel.parserError = err;
        goto reject;
    }
}
----

==== Semantics and the P4 abstract machines

We describe the semantics of P4 in terms of abstract machines executing
traditional imperative code. There is an abstract machine for each P4
sub-language (parser, control). The abstract machines are described in
this text in pseudo-code and English.

P4 compilers are free to reorganize the code they generate in any way as long as
the externally visible behaviors of the P4 programs are preserved as
described by this specification where externally visible behavior is defined as:

* The input/output behavior of all P4 blocks, and
* The state maintained by extern blocks.

=== Preprocessing

To aid composition of programs from multiple source files P4
compilers should support the following subset of the C preprocessor
functionality:

*	`#define` for defining macros (without arguments)
*	`#undef`
*	`#if #else #endif #ifdef #ifndef #elif`
*	`#include`

The preprocessor should also remove the sequence backslash newline (ASCII codes 92, 10)
to facilitate splitting content across multiple lines when convenient for formatting.

Additional C preprocessor capabilities may be supported, but
are not guaranteed---e.g., macros with arguments.  Similar to C, `#include`
can specify a file name either within double quotes or within `<>`.

[source,P4]
----
# include <system_file>
# include "user_file"
----

The difference between the two forms is the order in which the
preprocessor searches for header files when the path is incompletely
specified.

P4 compilers should correctly handle `#line` directives
that may be generated during preprocessing.  This functionality allows
P4 programs to be built from multiple source files, potentially
produced by different programmers at different times:

* the P4 core library, defined in this document,
* the architecture, defining data plane interfaces and extern blocks,
* user-defined libraries of useful components (e.g. standard
  protocol header definitions), and
* the P4 programs that specify the behavior of each programmable block.

=== P4 core library

The P4 language specification defines a core library that includes
several common programming constructs. A
description of the core library is provided in
<<_appendix_p4_core_library>>. All P4 programs must include the core
library. Including the core library is done with

[source,P4]
----
# include <core.p4>
----

=== Lexical constructs

All P4 keywords use only ASCII characters. All P4 identifiers must use
only ASCII characters. P4 compilers should handle correctly strings
containing 8-bit characters in comments and string literals.
P4 is case-sensitive.
Whitespace characters, including newlines are treated as token
separators. Indentation is free-form; however, P4 has C-like block
constructs, and all our examples use C-style indentation. Tab
characters are treated as spaces.

The lexer recognizes the following kinds of terminals:

* `IDENTIFIER`: start with a letter or underscore, and contain
  letters, digits and underscores
* `TYPE_IDENTIFIER`: identifier that denotes a type name
* `INTEGER`: integer literals
* `DONTCARE`: a single underscore
* Keywords such as `RETURN`. By convention, each keyword terminal corresponds to a
  language keyword with the same spelling but using lowercase. For
  example, the `RETURN` terminal corresponds to the `return`
  keyword.

==== Identifiers

P4 identifiers may contain only letters, numbers, and the underscore
character `_`, and must start with a letter or
underscore. The special identifier consisting of a single underscore `_`
is reserved to indicate a "don't care" value; its
type may vary depending on the context. Certain keywords (e.g., `apply`)
can be used as identifiers if the context makes it unambiguous.

[source,bison]
----
include::grammar.adoc[tag=nonTypeName]

name
    : nonTypeName
    | TYPE_IDENTIFIER
    ;
----

==== Comments

P4 supports several kinds of comments:

* Single-line comments, introduced by `//` and spanning to the end of line,
* Multi-line comments, enclosed between `/*` and `*/`
* Nested multi-line comments are not supported.
* Javadoc-style comments, starting with `/**` and ending with `*/`

Use of Javadoc-style comments is strongly encouraged for the tables and actions
that are used to synthesize the interface with the control-plane.

P4 treats comments as token separators and no comments are allowed within a
token---e.g. `bi/**/t` is parsed as two tokens, `bi` and `t`, and
not as a single token `bit`.

==== Literal constants

===== Boolean literals

There are two Boolean literal constants: `true` and `false`.

===== Integer literals

Integer literals are non-negative arbitrary-precision integers.
By default, literals are represented in base 10. The following prefixes
must be employed to specify the base explicitly:

* `0x` or `0X` indicates base 16 (hexadecimal)
* `0o` or `0O` indicates base 8 (octal)
* `0d` or `0D` indicates base 10 (decimal)
* `0b` or `0B` indicates base 2

The width of a numeric literal in bits can be specified by an unsigned
number prefix consisting of a number of bits and a signedness
indicator:

* `w` indicates unsigned numbers
* `s` indicates signed numbers

Note that a leading zero by itself does not indicate an
octal (base 8) constant.  The underscore character is considered a
digit within number literals but is ignored when computing the
value of the parsed number. This allows long constant numbers to be
more easily read by grouping digits together. The underscore cannot be
used in the width specification or as the first character of an
integer literal. No comments or whitespaces are allowed within a
literal. Here are some examples of numeric literals:

[source,P4]
----
32w255         // a 32-bit unsigned number with value 255
32w0d255       // same value as above
32w0xFF        // same value as above
32s0xFF        // a 32-bit signed number with value 255
8w0b10101010   // an 8-bit unsigned number with value 0xAA
8w0b_1010_1010 // same value as above
8w170          // same value as above
8s0b1010_1010  // an 8-bit signed number with value -86
16w0377        // 16-bit unsigned number with value 377 (not 255!)
16w0o377       // 16-bit unsigned number with value 255 (base 8)
----

===== String literals

String literals (string constants) are specified as an arbitrary
sequence of 8-bit characters, enclosed within double quote characters `"`
(ASCII code 34). Strings start with a double quote character
and extend to the first double quote sign which is not immediately
preceded by an odd number of backslash characters (ASCII code 92). P4
does not make any validity checks on strings (i.e., it does not check
that strings represent legal UTF-8 encodings).

Since P4 does not provide any operations on strings,
string literals are generally passed unchanged through the P4 compiler to
other third-party tools or compiler-backends, including the
terminating quotes. These tools can define their own handling of
escape sequences (e.g., how to specify Unicode characters, or handle
unprintable ASCII characters).

Here are 3 examples of string literals:
[source,P4]
----
"simple string"
"string \" with \" embedded \" quotes"
"string with embedded
line terminator"
----

==== Optional trailing commas

The P4 grammar allows several kinds of comma-separated lists to end in
an optional comma.

[source,bison]
----
include::grammar.adoc[tag=optTrailingComma]
----

For example, the following declarations are both legal, and
have the same meaning:

[source,P4]
----
enum E {
     a, b, c
}

enum E {
     a, b, c,
}
----

This is particularly useful in combination with preprocessor
directives:

[source,P4]
----
enum E {
#if SUPPORT_A
    a,
#endif
    b,
    c,
}
----

=== Naming conventions

P4 provides a rich assortment of types. Base types include bit-strings, numbers, and errors.
There are also built-in types for
representing constructs such as parsers, pipelines, actions, and
tables. Users can
construct new types based on these: structures, enumerations, headers,
header stacks, header unions, etc.

In this document we adopt the following conventions:

* Built-in types are written with lowercase characters---e.g., `int<20>`,
* User-defined types are capitalized---e.g., `IPv4Address`,
* Type variables are always uppercase---e.g., `parser P<H, IH>()`,
* Variables are uncapitalized--- e.g., `ipv4header`,
* Constants are written with uppercase characters---e.g., `CPU_PORT`, and
* Errors and enumerations are written in camel-case--- e.g. `PacketTooShort`.

=== P4 programs

A P4 program is a list of declarations:

[source,bison]
----
include::grammar.adoc[tag=p4program]

include::grammar.adoc[tag=declaration]
----

An empty declarations is indicated with a single semicolon. (Allowing empty
declarations accommodates the
habits of C/C++ and Java programmers---e.g., certain constructs, like `struct`,
do not require a terminating semicolon).

==== Scopes

Some P4 constructs act as namespaces that create local scopes for names including:

* Derived type declarations (`struct`, `header`, `header_union`, `enum`),
  which introduce local scopes for field names,
* Block statements, which introduce local lexically-enclosed scopes,
* `parser`, `table`, `action`, and `control` blocks, which
  introduce local scopes
* Declarations with type variables, which introduce a new scope for those
  variables. For example, in the following `extern` declaration,
  the scope of the type variable `H` extends to the end of the
  declaration:

[source,P4]
----
extern E<H>(/* parameters omitted */) { /* body omitted */ } // scope of H ends here.
----

The order of declarations is important; with the exception of parser
states, all uses of a symbol must follow the symbol's
declaration. (This is a departure from P4~14~, which
allows declarations in any order. This requirement significantly simplifies the implementation of
compilers for P4, allowing compilers to use additional information
about declared identifiers to resolve ambiguities.)

==== Stateful elements

Most P4 constructs are stateless: given some inputs they produce a
result that solely depends on these inputs. There are only two stateful constructs
that may retain information across packets:

* `table`s: Tables are read-only for the data plane, but their
  entries can be modified by the control-plane,

* `extern` objects: many objects have state that can be read and
  written by the control plane and data plane. All constructs from the P4~14~ language
  version that encapsulate state (e.g., counters, meters, registers) are
  represented using `extern` objects in P4~16~.

In P4 all stateful elements must be explicitly allocated at
compilation-time through the process called "instantiation".

In addition, ``parser``s, `control` blocks, and ``package``s
may contain stateful element instantiations. Thus, they are also
treated as stateful elements, even if they appear to contain no state,
and must be instantiated before they can be used. However, although
they are stateful, ``table``s do not need to be instantiated
explicitly---declaring a `table` also creates an instance of
it. This convention is designed to support the common case, since most
tables are used just once. To have finer-grained control over when
a `table` is instantiated, a programmer can declare it within
a `control`.

Recall the example in <<_a_complete_very_simple_switch_program>>: `TopParser`, `TopPipe`, `TopDeparser`, `Checksum16`,
and `Switch` are types. There are two instances of `Checksum16`, one in `TopParser` and
one in `TopDeparser`, both called `ck`. The `TopParser`, `TopDeparser`, `TopPipe`,
and `Switch` are instantiated at the end of the program, in the
declaration of the `main` instance object, which is an instance of
the `Switch` type (a `package`).

=== L-values

L-values are expressions that may appear on the left side of an
assignment operation or as arguments corresponding to `out` and `inout`
function parameters. An l-value represents a storage reference.  The
following expressions are legal l-values:

[source,bison]
----
include::grammar.adoc[tag=prefixedNonTypeName]

include::grammar.adoc[tag=lvalue]
----

* Identifiers of a base or derived type.
* Structure, header, and header union field member access operations
  (using the dot notation).
* References to elements within header stacks (see
  <<_operations_on_header_stacks>>): indexing, and references to `last` and `next`.
* The result of a bit-slice operator `[m:l]`.

The following is a legal l-value: `headers.stack[4].field`.  Note
that method and function calls cannot return l-values.

=== Calling convention: call by copy in/copy out

P4 provides multiple constructs for writing modular programs: extern
methods, parsers, controls, actions. All these constructs behave
similarly to procedures in standard general-purpose programming languages:

* They have named and typed parameters.
* They introduce a new local scope for parameters and local variables.
* They allow arguments to be passed by binding them to their
  parameters.

Invocations are executed using copy-in/copy-out semantics.

Each parameter may be labeled with a direction:

* `in` parameters are read-only. It is an error to use an `in`
  parameter on the left-hand side of an assignment or to
  pass it to a callee as a non-`in` argument. `in` parameters
  are initialized by copying the value of the corresponding
  argument when the invocation is executed.
* `out` parameters are, with a few exceptions listed below,
  uninitialized and are treated as l-values
  (See <<_L_values>>) within the body of the method or function.
  An argument passed as an `out`
  parameter must be an l-value; after the execution of the
  call, the value of the parameter is copied to the corresponding storage location
  for that l-value.
* `inout` parameters behave like a combination of `in` and `out` parameters simultaneously:
   On entry the value of the arguments is copied to the parameters.  On return the
   value of the parameters is copied back to the arguments.  In consequence, an argument
   passed as an `inout` parameter must be an l-value.
* The meaning of parameters with no direction depends upon the kind of
  entity the parameter is for:
** For anything other than an action, e.g. a control, parser, or
   function, a directionless parameter means that the value supplied
   as an argument in a call must be a compile-time known value
   (see <<_compile_time_known_values>>).
** For an action, a directionless parameter indicates that it is
   "action data".  See <<_actions>> for the meaning of
   action data, but its meaning includes the following possibilities:
*** The parameter's value is provided in the P4 program.  In this
    case, the parameter behaves as if the direction were `in`.  Such
    an argument expression need not be a compile-time known value.
*** The parameter's value is provided by the control plane software
    when an entry is added to a table that uses that action.  See
    <<_actions>>.

Direction `out` parameters are always initialized at the beginning of
execution of the portion of the program that has the `out` parameters,
e.g. `control`, `parser`, `action`, function, etc.  This
initialization is not performed for parameters with any direction that
is not `out`.

* If a direction `out` parameter is of type `header` or
  `header_union`, it is set to "invalid".
* If a direction `out` parameter is of type header stack, all elements
  of the header stack are set to "invalid", and its `nextIndex` field
  is initialized to 0 (see <<_operations_on_header_stacks>>).
* If a direction `out` parameter is a compound type, e.g. a struct or
  tuple, other than one of the types listed above, then apply these
  rules recursively to its members.
* If a direction `out` parameter has any other type, e.g. `bit<W>`, an
  implementation need not initialize it to any predictable value.

For example, if a direction `out` parameter has type `s2_t` named `p`:

[source,P4]
----
header h1_t {
    bit<8> f1;
    bit<8> f2;
}
struct s1_t {
    h1_t h1a;
    bit<3> a;
    bit<7> b;
}
struct s2_t {
    h1_t h1b;
    s1_t s1;
    bit<5> c;
}
----

then at the beginning of execution of the part of the program that has
the `out` parameter `p`, it must be initialized so that `p.h1b` and
and `p.s1.h1a` are invalid.  No other parts of `p` are required to be
initialized.

Arguments are evaluated from left to right prior to the invocation of the
function itself. The order of evaluation is important when the
expression supplied for an argument can have side-effects. Consider
the following example:

[source,P4]
----
extern void f(inout bit x, in bit y);
extern bit g(inout bit z);
bit a;
f(a, g(a));
----

Note that the evaluation of `g` may mutate its argument `a`, so the
compiler has to ensure that the value passed to `f` for its first
parameter is not changed by the evaluation of the second argument. The
semantics for evaluating a function call is given by the following
algorithm (implementations can be different as long as they provide
the same result):

1.	Arguments are evaluated from left to right as they appear in the
      function call expression.
2.      If a parameter has a default value and no corresponding argument is
      supplied, the default value is used as an argument.
3.	For each `out` and `inout` argument the corresponding
      l-value is saved (so it cannot be changed by the evaluation of
      the following arguments). This is important if the argument
      contains indexing operations into a header stack.
4.	The value of each argument is saved into a temporary.
5.	The function is invoked with the temporaries as arguments. We are
      guaranteed that the temporaries that are passed as arguments are
      never aliased to each other, so this "generated" function call
      can be implemented using call-by-reference if supported by the
      architecture.
6.	On function return, the temporaries that correspond to `out`
      or `inout` arguments are copied in order from left to right
      into the l-values saved in Step 3.

According to this algorithm, the previous function call is equivalent
to the following sequence of statements:

[source,P4]
----
bit tmp1 = a;     // evaluate a; save result
bit tmp2 = g(a);  // evaluate g(a); save result; modifies a
f(tmp1, tmp2);    // evaluate f; modifies tmp1
a = tmp1;         // copy inout result back into a
----

To see why Step 3 in the above algorithm is important, consider the following
example:

[source,P4]
----
header H { bit z; }
H[2] s;
f(s[a].z, g(a));
----

The evaluation of this call is equivalent to the following sequence of
statements:

[source,P4]
----
bit tmp1 = a;          // save the value of a
bit tmp2 = s[tmp1].z;  // evaluate first argument
bit tmp3 = g(a);       // evaluate second argument; modifies a
f(tmp2, tmp3);         // evaluate f; modifies tmp2
s[tmp1].z = tmp2;      // copy inout result back; dest is not s[a].z
----

When used as arguments, `extern` objects can only be passed as
directionless parameters---e.g., see the packet argument in the
very simple switch example.

==== Justification

The main reason for using copy-in/copy-out semantics (instead of the more common
call-by-reference semantics) is for controlling the side-effects of `extern`
functions and methods. `extern` methods and functions
are the main mechanism by which a P4 program communicates with its
environment. With copy-in/copy-out semantics `extern` functions
cannot hold references to P4 program objects; this enables the
compiler to limit the side-effects that `extern` functions may
have on the P4 program both in space (they can only affect `out`
parameters) and in time (side-effects can only occur at function call
time).

In general, `extern` functions are arbitrarily powerful: they can store
information in global storage, spawn separate threads, "collude" with
each other to share information --- but they cannot access any
variable in a P4 program. With copy-in/copy-out semantics the compiler
can still reason about P4 programs that invoke `extern`
functions.

There are additional benefits of using copy-in copy-out semantics:

* It enables P4 to be compiled for architectures that do not support
  references (e.g., where all data is allocated to named
  registers. Such architectures may require indices into header stacks that appear
  in a program to be compile-time known values.)
* It simplifies some compiler analyses, since function parameters can
  never alias to each other within the function body.

[source,bison]
----
include::grammar.adoc[tag=parameterList]

include::grammar.adoc[tag=nonEmptyParameterList]

include::grammar.adoc[tag=parameter]

include::grammar.adoc[tag=direction]
----

Following is a summary of the constraints imposed by the parameter
directions:

* When used as arguments, extern objects can only be passed as
  directionless parameters.
* All constructor parameters are evaluated at compilation-time, and in
  consequence they must all be directionless (they cannot be `in`,
  `out`, or `inout`); this applies to `package`, `control`, `parser`,
  and `extern` objects. Values for these parameters must be specified
  at compile-time, and must evaluate to compile-time known values.
  See <<_parameterization>> for further details.
* For actions all directionless parameters must be at the end of the
  parameter list.  When an action appears in a `table`'s `actions`
  list, only the parameters with a direction must be bound.
  See <<_actions>> for further details.
* Actions can also be explicitly invoked using function call syntax,
  either from a control block or from another action. In this case,
  values for all action parameters must be supplied explicitly,
  including values for the directionless parameters. The directionless
  parameters in this case behave like `in` parameters.
  See <<_invoking_actions>> for further details.
* Default parameter values are only allowed for 'in' or direction-less parameters;
  these values must evaluate to compile-time constants.
* If parameters with default values do not appear at the
  end of the list of parameters, invocations that use
  the default values must use named arguments, as in the following
  example:

[source,P4]
----
extern void f(in bit a, in bit<3> b = 2, in bit<5> c);

void g()
{
  f(a = 1, b = 2, c = 3);  // ok
  f(a = 1, c = 3);  // ok, equivalent to the previous call, b uses default value
  f(1, 2, 3);       // ok, equivalent to the previous call
  // f(1, 3); // illegal, since the parameter b is not the last in the list
}
----

==== Optional parameters

A parameter that is annotated with the `@optional` annotation is
optional: the user may omit the value for that parameter in an
invocation.  Optional parameters can only appear for arguments of:
packages, parser types, control types, extern functions, extern methods, and extern object
constructors.  Optional parameters cannot have default values.  If a
procedure-like construct has both optional parameters and default values then it
can only be called using named arguments.  It is recommended, but not
mandatory, for all optional parameters to be at the end of a parameter
list.

The implementation of such objects is not expressed in P4, so the
meaning and implementation of optional parameters should be specified
by the target architecture.  For example, we can imagine a two-stage
switch architecture where the second stage is optional. This could be
declared as a package with an optional parameter:

[source,P4]
----
package pipeline(/* parameters omitted */);
package switch(pipeline first, @optional pipeline second);

pipeline(/* arguments omitted */) ingress;
switch(ingress) main;   // a switch with a single-stage pipeline
----

Here the target architecture could implement the elided optional argument using an empty pipeline.

The following example shows optional parameters and parameters with
default values.

[source,P4]
----
extern void h(in bit<32> a, in bool b = true);  // default value

// function calls
h(10);  // same as h(10, true);
h(a = 10);  // same as h(10, true);
h(a = 10, b = true);

struct Empty {}
control nothing(inout Empty h, inout Empty m) {
   apply {}
}

parser parserProto<H, M>(packet_in p, out H h, inout M m);
control controlProto<H, M>(inout H h, inout M m);

package pack<HP, MP, HC, MC>(@optional parserProto<HP, MP> _parser,  // optional parameter
                             controlProto<HC, MC> _control = nothing()); // default parameter value

pack() main;   // No value for _parser, _control is an instance of nothing()
----

=== Name resolution

P4 objects that introduce namespaces are organized in a hierarchical
fashion. There is a top-level unnamed namespace containing all
top-level declarations.

Identifiers prefixed with a dot are always resolved in the top-level
namespace.

[source,P4]
----
const bit<32> x = 2;
control c() {
   int<32> x = 0;
   apply {
       x = x + (int<32>).x;  // x is the int<32> local variable,
                             // .x is the top-level bit<32> variable
   }
}
----

References to resolve an identifier are attempted inside-out, starting
with the current scope and proceeding to all lexically enclosing
scopes. The compiler may provide a warning if multiple resolutions are
possible for the same name (name shadowing).

[source,P4]
----
const bit<4> x = 1;
control p() {
    const bit<8> x = 8;    // x declaration shadows global x
    const bit<4> y = .x;   // reference to top-level x
    const bit<8> z = x;    // reference to p's local x
    apply {}
}
----

=== Visibility

Identifiers defined in the top-level namespace are globally
visible. Declarations within a `parser` or `control` are
private and cannot be referred to from outside of the enclosing `parser`
or `control`.


== P4 data types

== Expressions

== Compile-time size determination

== Function declarations

== Constants and variable declarations

== Statements

== Packet parsing

== Control blocks

== Parameterization

== Deparsing

== Architecture description

== P4 abstract machine: Evaluation

== Static assertions

== Annotations

[appendix]
== Appendix: Revision History

[appendix]
== Appendix: P4 reserved keywords

[appendix]
== Appendix: P4 reserved annotations

[appendix]
== Appendix: P4 core library

[appendix]
== Appendix: Checksums

[appendix]
== Appendix: Restrictions on compile time and run time calls

[appendix]
== Appendix: P4 grammar
